---
title: 你不知道的JavaScript
date: 2017-03-30 11:00:32
tags: 读书总结
---

第一章
    一、作用域
        1、编译原理
            分词/词法分析
            解析/语法分析
            代码生成
        2、理解作用域
            编译器
            引擎
                LHS和RHS查找
            作用域
        3、作用域嵌套
        4、异常
    二、词法作用域
        词法作用域 = 静态作用域
        动态作用域
        1、词法阶段
        2、欺骗语法
            eval()
                setTimeout()、setInterval()
                new Function()
            with()
    三、函数作用域和块级作用域
        1、函数中的作用域
        2、隐藏内部实现
        3、函数作用域
            匿名和具名
            立即执行函数表达式(IIFE)
        4、块作用域
            with
            try/catch
            let
            const
    四、提升
        1、先有声明后赋值
        2、函数优先
    五、作用域闭包
        1、实质问题
            当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行
            在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包
        2、循环和闭包
            每个迭代都被封闭在一个共享的全局作用域中
            利用IIFE为每个迭代都生成一个新的作用域
        3、模块
第二章
    一、关于this
        1、this到底是什么
            this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。
    二、this全面解析
        1、调用位置
            从调用栈中分析出真正的调用位置的，它决定了this的绑定。
        2、绑定规则
            默认绑定
            隐式绑定
                隐式丢失
            显式绑定（仍无法解决隐式丢失问题）
                硬绑定
                    硬绑定之后就无法使用隐式绑定或者显式绑定来修改this
                API调用的“上下文”
            new绑定
        3、优先级
            是否在new中调用（new绑定）？
                如果是的话this绑定的是新创建的对象。
            是否通过call、apply（显式绑定）或者硬绑定调用？
                如果是的话，this绑定的是指定的对象。
            是否在某个上下文对象中调用（隐式绑定）？
                如果是的话，this绑定的是那个上下文对象。
            都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。
        4、绑定例外
            被忽略的this
                传入null或undefined作为占位值this应用默认绑定规则
                    更安全的this，Object.create(null)
            间接引用
                调用这个函数会应用默认绑定规则
            软绑定
            this词法
    三、对象
        1、语法
            两种形式定义：声明形式和构造形式。
        2、类型
        3、内容
            可计算属性名
            属性与方法
            数组
                为数组添加命名属性，数组的length不改变
                    若属性名是数字，那它会变成一个数值下标（会修改数组的内容而不添加属性）
            复制对象

重构。。。


上卷 {

}

中卷 {
    类型与语法 {

    }

    异步与性能 {
        异步 {
            事件循环 {
                队列
                var eventLoop = [];
                var event;

                while(true) {
                    if(eventLoop.length > 0) {
                        event = envenLoop.shift();
                        try {
                            event();
                        } catch(e) {
                            reportError(err);
                        }
                    }
                }

                setTimeout() 在到时后才将回调函数放在事件循环中，永远不会调度到当前事件循环tick
            }
            Javascript 是单线程的使其函数中的代码执行具有原子性，即不中断完整运行
                减少了不确定性，相对多线程多进程只有事件顺序级别的
            并发 {
                非交互
                交互 {
                    协调交互避免竞态
                    措施 {
                        协调数序
                        条件判断，加上锁
                    }
                }
                协作 {
                    拆分自身，让其他并发有机会插入事件循环交替执行
                }
            }
            任务 {
                挂在事件循环队列每次tick之后的一个队列
                会在当前事件循环末尾添加
            }
            语句顺序 {
                js 引擎在编译完代码后会给这些js语句重新排序已提高执行速度
            }
        }

        回调 {
            代码抽象于生活，解释代码犹如思考的大脑
            开发者编写代码的时候是在计划一系列动作的发生，优秀的开发者会认真计划
            回调与我们大脑的顺序思维不匹配，以及控制反转带来的问题
                缺乏顺序性和可信任性
        }
        Promise {

        }
    }
}
